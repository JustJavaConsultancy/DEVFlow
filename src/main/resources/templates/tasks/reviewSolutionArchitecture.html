<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Review Solution Architecture</title>

  <!-- Provide CSRF tokens when Spring Security is active -->
  <meta th:if="${_csrf != null}" name="_csrf" th:content="${_csrf.token}"/>
  <meta th:if="${_csrf != null}" name="_csrf_header" th:content="${_csrf.headerName}"/>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Quill CSS -->
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">

  <!-- PlantUML rendering -->
  <script src="https://cdn.jsdelivr.net/npm/plantuml-encoder@1.4.0/dist/plantuml-encoder.min.js"></script>

  <!-- Code syntax highlighting -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github.min.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>

  <style>
    /* Editor container */
    #editor {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
      height: 80vh;
      overflow-y: auto;
    }

    /* Quill editor content */
    .ql-editor {
      min-height: 300px;
    }

    .ql-editor h1 {
      font-size: 1.875rem;
      font-weight: bold;
      color: #1e40af;
      margin-bottom: 1.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid #e2e8f0;
    }

    .ql-editor h2 {
      font-size: 1.5rem;
      font-weight: bold;
      color: #780aff;
      margin-top: 1.5rem;
      margin-bottom: 1rem;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid #e2e8f0;
    }

    .ql-editor h3 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #4b7bec;
      margin-top: 1.25rem;
      margin-bottom: 0.75rem;
    }

    .ql-editor h4 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #4b5563;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .ql-editor p {
      margin-bottom: 1rem;
      line-height: 1.6;
      color: #374151;
    }

    .ql-editor ul {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      list-style-type: disc;
    }

    .ql-editor ol {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      list-style-type: decimal;
    }

    .ql-editor li {
      margin-bottom: 0.5rem;
      line-height: 1.5;
    }

    .ql-editor strong {
      font-weight: 600;
      color: #4b5563;
    }

    /* Enhanced content styling */
    .enhanced-content {
      margin: 1rem 0;
    }

    /* Component box for architecture diagrams */
    .component-box {
      display: inline-block;
      background-color: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 16px;
      margin: 4px;
      font-weight: 500;
    }

    /* Architecture diagram styling */
    .architecture-diagram {
      background-color: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
      text-align: center;
    }

    .gradient-bg {
      background: linear-gradient(135deg, #780aff 0%, #4b7bec 100%);
    }

    /* Code block styling */
    .code-block {
      background-color: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin: 1rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
      overflow-x: auto;
      position: relative;
    }

    .code-block-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 0.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 1px solid #e9ecef;
    }

    .code-block-title {
      font-weight: 600;
      color: #495057;
    }

    .copy-button {
      background: #780aff;
      color: white;
      border: none;
      border-radius: 4px;
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      cursor: pointer;
      transition: background-color 0.2s;
    }

    .copy-button:hover {
      background: #6a00e6;
    }

    .copy-button.copied {
      background: #10b981;
    }

    /* PlantUML diagram container */
    .plantuml-diagram {
      background-color: white;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 1rem;
      margin: 1rem 0;
      text-align: center;
      overflow-x: auto;
    }

    .plantuml-diagram img {
      max-width: 100%;
      height: auto;
    }

    /* API endpoint styling */
    .api-endpoint {
      background-color: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin: 1rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
    }

    .api-method {
      display: inline-block;
      padding: 0.25rem 0.5rem;
      border-radius: 4px;
      font-weight: 600;
      margin-right: 0.5rem;
    }

    .api-method.get {
      background-color: #d1ecf1;
      color: #0c5460;
    }

    .api-method.post {
      background-color: #d4edda;
      color: #155724;
    }

    .api-method.put {
      background-color: #fff3cd;
      color: #856404;
    }

    .api-method.delete {
      background-color: #f8d7da;
      color: #721c24;
    }

    .api-path {
      color: #495057;
    }

    .api-description {
      margin-top: 0.5rem;
      font-size: 0.8rem;
      color: #6b7280;
    }

    /* Configuration example styling */
    .config-example {
      background-color: #f8f9fa;
      border: 1px solid #e9ecef;
      border-radius: 6px;
      padding: 1rem;
      margin: 1rem 0;
      font-family: 'Courier New', monospace;
      font-size: 0.875rem;
      overflow-x: auto;
    }

    /* Table embed visuals - Added from the original code */
    .ql-table-embed {
      margin:10px 0;
      padding:6px;
      background:transparent;
    }
    .ql-table-embed table {
      width:100%;
      border-collapse: collapse;
      table-layout:auto;
      background:white;
      font-size:14px;
    }
    .ql-table-embed th, .ql-table-embed td {
      border: 1px solid #d6dbe6;
      padding: 8px 10px;
      min-width:50px;
      vertical-align: top;
      white-space: pre-wrap;
      overflow-wrap: anywhere;
    }
    .ql-table-embed thead th {
      background: #f3f4f6;
      font-weight:600;
    }
    .ql-table-embed td[contenteditable="true"], .ql-table-embed th[contenteditable="true"] {
      outline: none;
      cursor:text;
      tabindex: 0;
    }
    .ql-table-embed td:focus, .ql-table-embed th:focus {
      box-shadow: 0 0 0 3px rgba(37,99,235,0.12);
    }

    /* Floating table toolbar - Updated to match your theme */
    .floating-toolbar {
      position: absolute;
      z-index: 50;
      display:flex;
      gap:6px;
      padding:6px;
      border-radius:8px;
      border:1px solid #e5e7eb;
      background: linear-gradient(180deg, #fff, #fbfbff);
      box-shadow: 0 6px 18px rgba(2,6,23,0.06);
      transition: opacity .12s ease, transform .12s ease;
      opacity: 0;
      pointer-events: none;
    }
    .floating-toolbar.show {
      opacity:1;
      pointer-events:auto;
      transform: translateY(-2px);
    }

    .floating-toolbar .btn-sm {
      padding:6px 8px;
      font-size:13px;
      border-radius:6px;
      background: white;
      border: 1px solid #e5e7eb;
      cursor: pointer;
    }
    .floating-toolbar .btn-sm:hover {
      background: #f9fafb;
    }

    /* Modal (Insert Table) - Updated to match your theme */
    .modal-backdrop {
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index:60;
      background: rgba(3,7,18,0.45);
    }
    .modal {
      width:360px;
      border-radius:10px;
      background:white;
      padding:14px;
      box-shadow: 0 20px 60px rgba(2,6,23,0.2);
      border:1px solid #e5e7eb;
    }
    .modal h3 {
      margin:0 0 8px 0;
      font-size:16px;
      font-weight: 600;
    }
    .modal .row {
      display:flex;
      gap:8px;
      margin-top:8px;
    }
    .modal label {
      font-size:13px;
      color:#6b7280;
      display:block;
      margin-bottom:6px;
    }
    .modal input[type="number"] {
      width:100%;
      padding:8px;
      border-radius:8px;
      border:1px solid #e5e7eb;
    }
    .modal .actions {
      display:flex;
      gap:8px;
      justify-content:flex-end;
      margin-top:12px;
    }
    .modal .help {
      font-size:13px;
      color:#6b7280;
      margin-top:8px;
    }

    /* Custom button styles */
    .btn {
      display:inline-flex;
      gap:8px;
      align-items:center;
      padding:8px 12px;
      border-radius:8px;
      border:1px solid #e5e7eb;
      background: white;
      cursor:pointer;
      font-size:14px;
      color: #374151;
    }
    .btn:hover {
      box-shadow: 0 6px 18px rgba(17,24,39,0.06);
    }

    /* make sure the table toolbar shows the font-awesome icon */
    .ql-toolbar .ql-table i { font-size: 14px; }

    /* Enhanced content toolbar styling */
    .ql-toolbar .ql-enhanced {
      border: none;
      background: none;
    }
    .ql-toolbar .ql-enhanced:hover {
      background: #f3f4f6;
    }
  </style>
</head>
<body>
<div layout:fragment="content">
  <!-- Page Title -->
  <div class="mb-8 mt-6">
    <h1 class="text-2xl md:text-3xl font-bold text-blue-800">
      <i class="fas fa-file-alt mr-3 text-blue-600"></i>
      Review Solution Architecture
    </h1>
    <p th:text="${processVariables.projectName}" class="text-gray-600 mt-2">E-Commerce Platform Project - v2.3</p>
  </div>

  <!-- Thymeleaf Form (kept so Complete Review still works server-side) -->
  <form id="architectureForm" th:action="@{/tasks/complete/{taskId}(taskId=${taskId})}" method="post">
    <div th:if="${_csrf != null}">
      <input type="hidden" th:name="${_csrf.parameterName}" th:value="${_csrf.token}"/>
    </div>

    <div class="bg-blue-50 border border-blue-100 rounded-lg p-4 mb-6 flex flex-wrap justify-between items-center">
      <div class="flex items-center">
        <span class="text-blue-800 mr-4 font-medium">Document Status:</span>
        <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-sm">Under Review</span>
        <!-- autosave status -->
        <span id="autosaveStatus" class="ml-4 text-sm text-gray-600">Not saved</span>
      </div>

      <div class="flex space-x-3 mt-3 md:mt-0">
        <button onclick="downloadAsPDF()" type="button" id="downloadBtn"
                class="gradient-bg text-white px-4 py-2 rounded-lg flex items-center action-btn">
          <i class="fas fa-download mr-2"></i> Download
        </button>
      </div>
    </div>

    <!-- Hidden input used for the final form submit -->
    <input type="hidden" name="architecture" id="editedDocument"/>

    <!-- Editor wrapper with floating toolbar -->
    <div class="editor-wrapper relative bg-white rounded-lg shadow-sm border border-gray-200">
      <!-- Quill Editor (editable) -->
      <div id="editor" th:utext="${processVariables.architecture}"></div>

      <!-- Floating table toolbar (hidden until a cell is focused) -->
      <div id="floating-toolbar" class="floating-toolbar" aria-hidden="true">
        <button id="ft-add-row" class="btn-sm">+ Row</button>
        <button id="ft-add-col" class="btn-sm">+ Col</button>
        <button id="ft-del-row" class="btn-sm">Del Row</button>
        <button id="ft-del-col" class="btn-sm">Del Col</button>
        <button id="ft-del-table" class="btn-sm" style="color:#b91c1c;border-color:#f1d4d4">Delete Table</button>
      </div>
    </div>

    <!-- Complete Button -->
    <div th:if="${!isCompleted}" class="flex justify-center mt-6">
      <button type="submit" id="submitBtn"
              class="gradient-bg text-white px-6 py-3 rounded-lg flex items-center action-btn">
        <i class="fas fa-check-circle mr-2"></i>
        Complete Review
      </button>
    </div>
  </form>

  <!-- Insert table modal -->
  <div id="insert-modal" class="modal-backdrop" role="dialog" aria-modal="true" aria-hidden="true">
    <div class="modal" role="document" aria-labelledby="modal-title">
      <h3 id="modal-title">Insert table</h3>
      <div class="row">
        <div style="flex:1">
          <label for="input-rows">Rows</label>
          <input id="input-rows" type="number" min="1" max="100" value="3">
        </div>
        <div style="width:120px">
          <label for="input-cols">Columns</label>
          <input id="input-cols" type="number" min="1" max="100" value="3">
        </div>
      </div>
      <div style="margin-top:8px;">
        <label><input id="input-header" type="checkbox"> Include header row</label>
      </div>
      <div class="help">Tip: Use Tab to move between cells. Press Esc in a cell to return to the editor.</div>
      <div class="actions">
        <button id="modal-cancel" class="btn">Cancel</button>
        <button id="modal-insert" class="btn" style="background:#780aff; color:white; border-color: transparent;">Insert</button>
      </div>
    </div>
  </div>

  <!-- Hidden logo for PDF generation -->
  <img id="pdfLogo" th:src="@{/images/JJ LOGOMARK COLORED.png}" alt="Company Logo" style="display: none;">

  <!-- Scripts: htmx (for AJAX), Quill, jsPDF (kept) -->
  <script src="https://unpkg.com/htmx.org@1.9.2"></script>
  <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <script>
    /*********************************
     * Enhanced Content Blots for Quill
     *********************************/
    const BlockEmbed = Quill.import('blots/block/embed');
    const Block = Quill.import('blots/block');

    // PlantUML Diagram Blot
    class PlantUMLBlot extends BlockEmbed {
      static blotName = 'plantuml-diagram';
      static tagName = 'div';
      static className = 'plantuml-diagram enhanced-content';

      static create(value) {
        const node = super.create();
        node.setAttribute('data-plantuml', value);
        node.innerHTML = `
          <div class="flex justify-center items-center h-64">
            <div class="text-center">
              <i class="fas fa-spinner fa-spin text-blue-500 text-2xl mb-2"></i>
              <p>Loading diagram...</p>
            </div>
          </div>
        `;
        return node;
      }

      static value(node) {
        return node.getAttribute('data-plantuml');
      }
    }

    // Code Block Blot
    class CodeBlockBlot extends Block {
      static blotName = 'code-block';
      static tagName = 'div';
      static className = 'code-block enhanced-content';

      static create(value) {
        const node = super.create();
        const { code, language, title } = value;
        node.innerHTML = `
          <div class="code-block-header">
            <span class="code-block-title">${title || 'Code'}</span>
            <button class="copy-button">Copy</button>
          </div>
          <pre><code class="language-${language}">${code}</code></pre>
        `;
        return node;
      }

      static value(node) {
        const codeElement = node.querySelector('code');
        const titleElement = node.querySelector('.code-block-title');
        return {
          code: codeElement ? codeElement.textContent : '',
          language: codeElement ? codeElement.className.replace('language-', '') : '',
          title: titleElement ? titleElement.textContent : ''
        };
      }
    }

    // API Endpoint Blot
    class APIEndpointBlot extends BlockEmbed {
      static blotName = 'api-endpoint';
      static tagName = 'div';
      static className = 'api-endpoint enhanced-content';

      static create(value) {
        const node = super.create();
        const { method, path, description } = value;
        const methodClass = `api-method ${method.toLowerCase()}`;
        node.innerHTML = `
          <div>
            <span class="${methodClass}">${method.toUpperCase()}</span>
            <span class="api-path">${path}</span>
            ${description ? `<p class="api-description">${description}</p>` : ''}
          </div>
        `;
        return node;
      }

      static value(node) {
        const methodElement = node.querySelector('.api-method');
        const pathElement = node.querySelector('.api-path');
        const descriptionElement = node.querySelector('.api-description');
        return {
          method: methodElement ? methodElement.textContent.toLowerCase() : '',
          path: pathElement ? pathElement.textContent : '',
          description: descriptionElement ? descriptionElement.textContent : ''
        };
      }
    }

    // Configuration Example Blot
    class ConfigExampleBlot extends Block {
      static blotName = 'config-example';
      static tagName = 'div';
      static className = 'config-example enhanced-content';

      static create(value) {
        const node = super.create();
        const { code, language } = value;
        node.innerHTML = `
          <pre><code class="language-${language}">${code}</code></pre>
        `;
        return node;
      }

      static value(node) {
        const codeElement = node.querySelector('code');
        return {
          code: codeElement ? codeElement.textContent : '',
          language: codeElement ? codeElement.className.replace('language-', '') : ''
        };
      }
    }

    // Register all custom blots
    Quill.register(PlantUMLBlot);
    Quill.register(CodeBlockBlot);
    Quill.register(APIEndpointBlot);
    Quill.register(ConfigExampleBlot);

    /*********************************
     * Initialize syntax highlighting and PlantUML rendering
     *********************************/
    document.addEventListener('DOMContentLoaded', function() {
      // Initialize syntax highlighting
      hljs.highlightAll();

      // Render PlantUML diagrams
      renderPlantUMLDiagrams();

      // Add copy functionality to code blocks
      setupCopyButtons();
    });

    /*********************************
     * PlantUML Diagram Rendering
     *********************************/
    function renderPlantUMLDiagrams() {
      const diagramContainers = document.querySelectorAll('.plantuml-diagram[data-plantuml]');

      diagramContainers.forEach(container => {
        const plantumlCode = container.getAttribute('data-plantuml');
        if (plantumlCode) {
          // Encode the PlantUML code
          const encoded = plantumlEncoder.encode(plantumlCode);
          // Generate the URL for the PlantUML server
          const url = `https://www.plantuml.com/plantuml/svg/${encoded}`;

          // Create and append the image
          const img = document.createElement('img');
          img.src = url;
          img.alt = 'PlantUML Diagram';
          img.className = 'max-w-full h-auto';
          img.onload = function() {
            // Replace loading indicator with the image
            container.innerHTML = '';
            container.appendChild(img);
          };
          img.onerror = function() {
            // If image fails to load, show error message
            container.innerHTML = `
              <div class="text-center p-4 text-red-600">
                <i class="fas fa-exclamation-triangle text-xl mb-2"></i>
                <p>Failed to load diagram</p>
                <button class="mt-2 text-sm text-blue-500 underline" onclick="renderPlantUMLDiagrams()">Retry</button>
              </div>
            `;
          };
        }
      });
    }

    /*********************************
     * Copy Button Setup
     *********************************/
    function setupCopyButtons() {
      document.addEventListener('click', function(e) {
        if (e.target.classList.contains('copy-button')) {
          copyCode(e.target);
        }
      });
    }

    /*********************************
     * Code Copy Functionality
     *********************************/
    function copyCode(button) {
      const codeBlock = button.closest('.code-block, .config-example');
      const codeElement = codeBlock.querySelector('code');
      const codeText = codeElement.textContent;

      navigator.clipboard.writeText(codeText).then(() => {
        // Visual feedback for successful copy
        const originalText = button.textContent;
        button.textContent = 'Copied!';
        button.classList.add('copied');

        setTimeout(() => {
          button.textContent = originalText;
          button.classList.remove('copied');
        }, 2000);
      }).catch(err => {
        console.error('Failed to copy code: ', err);
        alert('Failed to copy code to clipboard');
      });
    }

    /*********************************
     * Enhanced Content Insertion Functions
     *********************************/
    function insertPlantUMLDiagram(plantumlCode) {
      const range = quill.getSelection(true);
      quill.insertEmbed(range.index, 'plantuml-diagram', plantumlCode, Quill.sources.USER);
      quill.insertText(range.index + 1, '\n', Quill.sources.USER);
      setTimeout(renderPlantUMLDiagrams, 100);
    }

    function insertCodeBlock(code, language = 'plaintext', title = 'Code') {
      const range = quill.getSelection(true);
      quill.insertEmbed(range.index, 'code-block', { code, language, title }, Quill.sources.USER);
      quill.insertText(range.index + 1, '\n', Quill.sources.USER);
      setTimeout(() => {
        hljs.highlightAll();
        setupCopyButtons();
      }, 100);
    }

    function insertAPIEndpoint(method, path, description = '') {
      const range = quill.getSelection(true);
      quill.insertEmbed(range.index, 'api-endpoint', { method, path, description }, Quill.sources.USER);
      quill.insertText(range.index + 1, '\n', Quill.sources.USER);
    }

    function insertConfigExample(code, language = 'yaml') {
      const range = quill.getSelection(true);
      quill.insertEmbed(range.index, 'config-example', { code, language }, Quill.sources.USER);
      quill.insertText(range.index + 1, '\n', Quill.sources.USER);
      setTimeout(() => {
        hljs.highlightAll();
        setupCopyButtons();
      }, 100);
    }

    /*********************************
     * Table embed blot (editable cells)
     *********************************/
    class TableBlot extends BlockEmbed {
      static blotName = 'table-embed';
      static tagName = 'div';
      static className = 'ql-table-embed';

      static create(value) {
        const node = super.create();
        node.setAttribute('contenteditable', 'false');
        node.innerHTML = value;

        // Make cells editable
        const cells = node.querySelectorAll('td, th');
        cells.forEach(c => {
          c.setAttribute('contenteditable', 'true');
          c.setAttribute('tabindex', '0');
          if (c.innerHTML.trim() === '') c.innerHTML = '<br>';
        });

        return node;
      }

      static value(node) {
        const table = node.querySelector('table');
        return table ? table.outerHTML : '';
      }
    }

    Quill.register(TableBlot);

    /*********************************
     * Preprocess existing server-side tables BEFORE Quill initializes.
     *********************************/
    (function preprocessInitialTables() {
      const editorEl = document.getElementById('editor');
      if (!editorEl) return;
      const tables = Array.from(editorEl.querySelectorAll('table'));
      if (tables.length === 0) return;

      tables.forEach(table => {
        if (table.closest('.ql-table-embed')) return;

        const cloned = table.cloneNode(true);
        cloned.querySelectorAll('td, th').forEach(c => {
          c.setAttribute('contenteditable', 'true');
          c.setAttribute('tabindex', '0');
          if (c.innerHTML.trim() === '') c.innerHTML = '<br>';
        });

        const wrapper = document.createElement('div');
        wrapper.className = 'ql-table-embed';
        wrapper.setAttribute('contenteditable', 'false');
        wrapper.innerHTML = cloned.outerHTML;

        table.parentNode.replaceChild(wrapper, table);
      });
    })();

    /*********************************
     * Initialize Quill with enhanced toolbar
     *********************************/
    var quill = new Quill('#editor', {
      theme: 'snow',
      modules: {
        toolbar: {
          container: [
            [{ header: [1, 2, 3, false] }],
            ['bold', 'italic', 'underline', 'strike'],
            [{ list: 'ordered' }, { list: 'bullet' }],
            ['link', 'image', 'code-block'],
            [{ color: [] }, { background: [] }],
            ['table'],
            ['clean']
          ],
          handlers: {
            'table': function() {
              document.getElementById('insert-modal').style.display = 'flex';
              document.getElementById('insert-modal').setAttribute('aria-hidden', 'false');
              document.getElementById('input-rows').focus();
            }
          }
        }
      }
    });

    // Add enhanced content buttons to toolbar
    function addEnhancedContentToolbar() {
      const toolbar = document.querySelector('.ql-toolbar');
      if (!toolbar) return;

      const enhancedContentHtml = `
        <span class="ql-formats">
          <button class="ql-plantuml" title="Insert PlantUML Diagram">
            <i class="fas fa-project-diagram"></i>
          </button>
          <button class="ql-api" title="Insert API Endpoint">
            <i class="fas fa-code"></i>
          </button>
          <button class="ql-config" title="Insert Configuration">
            <i class="fas fa-cog"></i>
          </button>
        </span>
      `;

      toolbar.insertAdjacentHTML('beforeend', enhancedContentHtml);

      // Add event listeners for enhanced content buttons
      document.querySelector('.ql-plantuml').addEventListener('click', function() {
        const plantumlCode = prompt('Enter PlantUML code:');
        if (plantumlCode) {
          insertPlantUMLDiagram(plantumlCode);
        }
      });

      document.querySelector('.ql-api').addEventListener('click', function() {
        const method = prompt('Enter HTTP method (GET, POST, PUT, DELETE):', 'GET');
        const path = prompt('Enter API path:', '/api/v1/endpoint');
        const description = prompt('Enter description (optional):', '');
        if (method && path) {
          insertAPIEndpoint(method, path, description);
        }
      });

      document.querySelector('.ql-config').addEventListener('click', function() {
        const language = prompt('Enter language (yaml, java, javascript, etc.):', 'yaml');
        const code = prompt('Enter configuration code:');
        if (code) {
          insertConfigExample(code, language);
        }
      });
    }

    // Ensure the table toolbar button shows a Font Awesome icon
    (function decorateTableToolbarButton() {
      const btn = document.querySelector('.ql-toolbar .ql-table');
      if (btn) {
        btn.innerHTML = '<i class="fas fa-table" aria-hidden="true"></i>';
        btn.setAttribute('title', 'Insert table');
      }
    })();

    // Add enhanced content toolbar and initialize
    setTimeout(() => {
      addEnhancedContentToolbar();
      attachCellBehaviorToAllTables();
      convertExistingTablesToEmbeds();
      processEnhancedContent();
    }, 50);

    /*********************************
     * Process enhanced content elements
     *********************************/
    function processEnhancedContent() {
      // Add copy buttons to existing code blocks
      document.querySelectorAll('.code-block').forEach(block => {
        if (!block.querySelector('.copy-button')) {
          const header = block.querySelector('.code-block-header');
          if (header) {
            const copyBtn = document.createElement('button');
            copyBtn.className = 'copy-button';
            copyBtn.textContent = 'Copy';
            header.appendChild(copyBtn);
          }
        }
      });

      // Re-highlight code after content changes
      hljs.highlightAll();
    }

    // convenience refs
    const wrapper = document.querySelector('.editor-wrapper');
    const floatingToolbar = document.getElementById('floating-toolbar');
    let currentCell = null;
    let currentEmbedNode = null;

    /*********************************
     * Table Utilities
     *********************************/
    function createTableHtml(rows, cols, header) {
      rows = Math.max(1, Math.floor(rows));
      cols = Math.max(1, Math.floor(cols));
      let html = '<table>';
      if (header) {
        html += '<thead><tr>';
        for (let c = 0; c < cols; c++) html += '<th><br></th>';
        html += '</tr></thead>';
      }
      html += '<tbody>';
      const bodyRows = header ? rows - 1 : rows;
      for (let r = 0; r < Math.max(0, bodyRows); r++) {
        html += '<tr>';
        for (let c = 0; c < cols; c++) html += '<td><br></td>';
        html += '</tr>';
      }
      html += '</tbody></table>';
      return html;
    }

    function placeCaretAtEnd(el) {
      el = el || document;
      const range = document.createRange();
      range.selectNodeContents(el);
      range.collapse(false);
      const sel = window.getSelection();
      sel.removeAllRanges();
      sel.addRange(range);
    }

    // Insert HTML at a Quill index; preserves table nodes as table-embed
    function insertHtmlAtIndex(html, index) {
      const wrapperDom = document.createElement('div');
      wrapperDom.innerHTML = html;
      let nodes = Array.from(wrapperDom.childNodes);
      let currentIndex = Math.max(0, index);

      nodes.forEach(node => {
        if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'TABLE') {
          quill.insertEmbed(currentIndex, 'table-embed', node.outerHTML, Quill.sources.USER);
          currentIndex += 2;
        } else {
          const fragHtml = node.outerHTML ?? node.textContent ?? '';
          quill.clipboard.dangerouslyPasteHTML(currentIndex, fragHtml);
          currentIndex = quill.getLength() - 1;
        }
      });

      attachCellBehaviorToAllTables();
      processEnhancedContent();
    }

    function loadHtmlIntoEditor(html) {
      quill.setContents([]);
      insertHtmlAtIndex(html, 0);
    }

    function getEditorHtmlPreservingTables() {
      const container = quill.root;
      const outParts = Array.from(container.childNodes).map(node => {
        if (node.nodeType === Node.ELEMENT_NODE && node.classList.contains('ql-table-embed')) {
          const table = node.querySelector('table');
          return table ? table.outerHTML : '';
        } else if (node.nodeType === Node.ELEMENT_NODE && node.tagName === 'TABLE') {
          return node.outerHTML;
        } else {
          return node.outerHTML ?? node.textContent ?? '';
        }
      });
      return outParts.join('');
    }

    /*********************************
     * Paste handler (intercept HTML tables)
     *********************************/
    quill.root.addEventListener('paste', e => {
      const clipboardData = (e.clipboardData || window.clipboardData);
      if (!clipboardData) return;
      const html = clipboardData.getData('text/html');
      if (!html) return; // let Quill handle plain-text
      if (/<table[\s>]/i.test(html)) {
        e.preventDefault();
        const sel = quill.getSelection(true);
        const index = sel ? sel.index : quill.getLength() - 1;
        insertHtmlAtIndex(html, index);
      }
    });

    /*********************************
     * Cell behaviors: tab navigation, enter handling, focus tracking
     *********************************/
    function attachCellBehaviorToAllTables() {
      const embeds = quill.root.querySelectorAll('.ql-table-embed');
      embeds.forEach(embed => {
        const table = embed.querySelector('table');
        if (!table) return;
        const cells = Array.from(table.querySelectorAll('td, th'));
        cells.forEach(cell => {
          if (cell.dataset._tblHandlers === '1') return;
          cell.dataset._tblHandlers = '1';

          // Focus tracking: show floating toolbar
          cell.addEventListener('focus', (ev) => {
            currentCell = cell;
            currentEmbedNode = embed;
            showFloatingToolbarNearCell(cell);
          });

          // Key handling
          cell.addEventListener('keydown', ev => {
            // Tab navigation
            if (ev.key === 'Tab') {
              ev.preventDefault();
              const allCells = Array.from(table.querySelectorAll('td, th'));
              const idx = allCells.indexOf(cell);
              if (idx === -1) return;
              const forward = !ev.shiftKey;
              let nextIdx = forward ? idx + 1 : idx - 1;
              if (nextIdx < 0) nextIdx = allCells.length - 1;
              if (nextIdx >= allCells.length) nextIdx = 0;
              const nextCell = allCells[nextIdx];
              if (nextCell) {
                nextCell.focus();
                placeCaretAtEnd(nextCell);
              }
            }

            // Enter should insert a line break inside cell instead of making a new Quill block
            if (ev.key === 'Enter') {
              ev.preventDefault();
              // insert a <br> at caret position
              // use execCommand as a small fallback for contenteditable cells
              document.execCommand('insertHTML', false, '<br>');
            }

            // Escape: move focus to Quill editor root
            if (ev.key === 'Escape') {
              ev.stopPropagation();
              quill.focus();
            }
          });

          // Keep an empty placeholder so caret can go into empty cell
          cell.addEventListener('blur', () => {
            if (cell.textContent.trim() === '') cell.innerHTML = '<br>';
          });
        });
      });
    }

    // initial attach in case content pre-exists
    attachCellBehaviorToAllTables();

    /*********************************
     * Floating toolbar (Add/Delete row/col, Delete table)
     *********************************/
    function showFloatingToolbarNearCell(cell) {
      // compute position relative to editor wrapper
      const editorRect = quill.root.getBoundingClientRect();
      const wrapperRect = wrapper.getBoundingClientRect();
      const cellRect = cell.getBoundingClientRect();

      // account for editor scroll
      const top = (cellRect.top - editorRect.top) + quill.root.scrollTop - floatingToolbar.offsetHeight - 6;
      // position left aligned with cell (but ensure it stays within wrapper)
      let left = (cellRect.left - wrapperRect.left) + quill.root.scrollLeft;
      // clamp left
      const maxLeft = wrapper.clientWidth - floatingToolbar.offsetWidth - 8;
      if (left < 8) left = 8;
      if (left > maxLeft) left = maxLeft;

      floatingToolbar.style.top = `${top}px`;
      floatingToolbar.style.left = `${left}px`;
      floatingToolbar.classList.add('show');
      floatingToolbar.setAttribute('aria-hidden', 'false');
    }

    function hideFloatingToolbar() {
      floatingToolbar.classList.remove('show');
      floatingToolbar.setAttribute('aria-hidden', 'true');
      currentCell = null;
      currentEmbedNode = null;
    }

    // hide toolbar when clicking outside any table cell
    document.addEventListener('click', (e) => {
      if (!e.target.closest('.ql-table-embed') && !e.target.closest('#floating-toolbar') && !e.target.closest('.modal')) {
        // if click is outside table embed and outside toolbar and not modal, hide toolbar
        hideFloatingToolbar();
      }
    });

    // Keep toolbar visible while interacting with it
    floatingToolbar.addEventListener('mouseenter', () => {
      floatingToolbar.dataset.hover = '1';
    });
    floatingToolbar.addEventListener('mouseleave', () => {
      floatingToolbar.dataset.hover = '0';
    });

    /*********************************
     * Table structure operations
     *********************************/
    function addRowBelow(cell) {
      if (!cell) return;
      const tr = cell.closest('tr');
      const table = cell.closest('table');
      const rows = Array.from(table.rows);
      const rowIndex = rows.indexOf(tr);
      // compute columns count using max cells of current row
      const cols = tr.cells.length;
      const createdTr = document.createElement('tr');
      for (let c = 0; c < cols; c++) {
        const td = document.createElement('td');
        td.innerHTML = '<br>';
        createdTr.appendChild(td);
      }
      // insert createdTr after current tr
      if (tr.nextSibling) tr.parentNode.insertBefore(createdTr, tr.nextSibling);
      else tr.parentNode.appendChild(createdTr);
      attachCellBehaviorToAllTables();
      // focus new row's first cell
      const createdCell = createdTr.querySelector('td,th');
      if (createdCell) {
        createdCell.focus();
        placeCaretAtEnd(createdCell);
      }
    }

    function deleteRow(cell) {
      if (!cell) return;
      const tr = cell.closest('tr');
      const table = cell.closest('table');
      // if only one row left (consider tbody rows) -> remove entire table
      const bodyRows = table.tBodies.length ? table.tBodies[0].rows.length : table.rows.length;
      // count total rows in table.rows (includes thead)
      if (table.rows.length <= 1) {
        removeEntireTable(table);
        return;
      }
      tr.parentNode.removeChild(tr);
      attachCellBehaviorToAllTables();
      quill.focus();
    }

    function addColumnAfter(cell) {
      if (!cell) return;
      const table = cell.closest('table');
      const tr = cell.closest('tr');
      // Find column index of cell within its row
      const colIndex = Array.from(tr.cells).indexOf(cell);
      // For each row in table.rows, insert a new cell after colIndex
      Array.from(table.rows).forEach(row => {
        // decide cell type: if row is thead and originally header, create th else td
        const isTheadRow = row.parentElement && row.parentElement.tagName === 'THEAD';
        const newCell = isTheadRow ? document.createElement('th') : document.createElement('td');
        newCell.innerHTML = '<br>';
        // if row has fewer cells than index+1, append; else insert before existing cell at colIndex+1
        if (row.cells.length <= colIndex) {
          row.appendChild(newCell);
        } else {
          // insert after the reference cell
          const ref = row.cells[colIndex];
          if (ref.nextSibling) row.insertBefore(newCell, ref.nextSibling);
          else row.appendChild(newCell);
        }
      });
      attachCellBehaviorToAllTables();
      // focus the inserted cell that corresponds to original cell's row
      const insertedCell = tr.cells[colIndex + 1] || tr.cells[tr.cells.length - 1];
      if (insertedCell) {
        insertedCell.focus();
        placeCaretAtEnd(insertedCell);
      }
    }

    function deleteColumn(cell) {
      if (!cell) return;
      const table = cell.closest('table');
      const tr = cell.closest('tr');
      const colIndex = Array.from(tr.cells).indexOf(cell);
      // Remove each cell at colIndex across rows (if exists)
      Array.from(table.rows).forEach(row => {
        if (row.cells.length > colIndex) {
          row.deleteCell(colIndex);
        }
      });
      // If table now has zero columns (rows with 0 cells), remove table
      const remainingCols = Array.from(table.rows).reduce((acc, r) => Math.max(acc, r.cells.length), 0);
      if (remainingCols === 0) {
        removeEntireTable(table);
        return;
      }
      attachCellBehaviorToAllTables();
      quill.focus();
    }

    function removeEntireTable(table) {
      // remove the .ql-table-embed wrapper, replacing with an empty paragraph.
      const embed = table.closest('.ql-table-embed');
      if (!embed) return;
      // compute insertion index among editor child nodes
      const parent = quill.root;
      const nodes = Array.from(parent.childNodes);
      const idx = nodes.indexOf(embed);
      // remove embed DOM
      embed.remove();
      // insert empty paragraph to keep editor layout sane
      const p = document.createElement('p');
      p.innerHTML = '<br>';
      if (idx >= nodes.length || nodes.length === 0) parent.appendChild(p); else parent.insertBefore(p, parent.childNodes[idx]);
      attachCellBehaviorToAllTables();
      hideFloatingToolbar();
      quill.focus();
    }

    /*********************************
     * Floating toolbar button wiring
     *********************************/
    document.getElementById('ft-add-row').addEventListener('click', () => {
      addRowBelow(currentCell);
    });
    document.getElementById('ft-del-row').addEventListener('click', () => {
      deleteRow(currentCell);
    });
    document.getElementById('ft-add-col').addEventListener('click', () => {
      addColumnAfter(currentCell);
    });
    document.getElementById('ft-del-col').addEventListener('click', () => {
      deleteColumn(currentCell);
    });
    document.getElementById('ft-del-table').addEventListener('click', () => {
      const table = currentCell ? currentCell.closest('table') : null;
      if (table && confirm('Delete the entire table?')) removeEntireTable(table);
    });

    /*********************************
     * Insert table modal + main controls
     *********************************/
    const modal = document.getElementById('insert-modal');
    const modalInsert = document.getElementById('modal-insert');
    const modalCancel = document.getElementById('modal-cancel');

    modalCancel.addEventListener('click', () => {
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      quill.focus();
    });

    modalInsert.addEventListener('click', () => {
      const rows = parseInt(document.getElementById('input-rows').value, 10) || 1;
      const cols = parseInt(document.getElementById('input-cols').value, 10) || 1;
      const header = document.getElementById('input-header').checked;
      const html = '<p></p>' + createTableHtml(rows, cols, header) + '<p><br></p>';
      const sel = quill.getSelection(true);
      const index = sel ? sel.index : quill.getLength() - 1;
      insertHtmlAtIndex(html, index);
      modal.style.display = 'none';
      modal.setAttribute('aria-hidden', 'true');
      quill.focus();
    });

    // Allow Esc to close modal
    document.addEventListener('keydown', (e) => {
      if (e.key === 'Escape') {
        if (modal.style.display === 'flex') {
          modal.style.display = 'none';
          modal.setAttribute('aria-hidden', 'true');
          quill.focus();
        }
      }
    });

    /*********************************
     * Fallback converter (run after init) - replaces any raw TABLE nodes inside Quill root
     * with our ql-table-embed wrappers so that getEditorHtmlPreservingTables() and behaviors work.
     *********************************/
    function convertExistingTablesToEmbeds() {
      const editor = quill.root;
      const tables = Array.from(editor.querySelectorAll('table'));
      if (tables.length === 0) return;

      tables.reverse().forEach(table => {
        // skip if already inside wrapper
        if (table.closest('.ql-table-embed')) return;

        const cloned = table.cloneNode(true);
        cloned.querySelectorAll('td, th').forEach(c => {
          c.setAttribute('contenteditable', 'true');
          c.setAttribute('tabindex', '0');
          if (c.innerHTML.trim() === '') c.innerHTML = '<br>';
        });

        const wrapper = document.createElement('div');
        wrapper.className = 'ql-table-embed';
        wrapper.setAttribute('contenteditable', 'false');
        wrapper.innerHTML = cloned.outerHTML;

        table.parentNode.replaceChild(wrapper, table);
      });

      attachCellBehaviorToAllTables();
    }

    /*********************************
     * CSRF integration and autosave
     *********************************/
    (function setupHtmxCsrf() {
      const metaToken = document.querySelector('meta[name="_csrf"]');
      const metaHeader = document.querySelector('meta[name="_csrf_header"]');
      if (metaToken && metaHeader && window.htmx) {
        const csrfToken = metaToken.getAttribute('content');
        const csrfHeader = metaHeader.getAttribute('content');
        // Add the CSRF header to every htmx request:
        document.addEventListener('htmx:configRequest', function (evt) {
          evt.detail.headers[csrfHeader] = csrfToken;
        });
      }
    })();

    // Debounced autosave using htmx.ajax on Quill changes
    const autosaveStatus = document.getElementById('autosaveStatus');
    let saveTimeout = null;
    const AUTOSAVE_DEBOUNCE_MS = 800; // reduce spamming by debouncing

    function autosaveContent() {
      const html = getEditorHtmlPreservingTables();
      autosaveStatus.textContent = 'Saving...';

      // use htmx.ajax to POST form-encoded data { requirement: html } to your endpoint
      // endpoint: POST /api/richtext
      htmx.ajax('POST', '/richtext/architecture', {
        values: {
          requirement: html,
          taskId: '[[${taskId}]]'
        },
        swap: 'none' // we don't want to swap any content back into the page
      });
    }

    // debounce wrapper
    quill.on('text-change', function () {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(autosaveContent, AUTOSAVE_DEBOUNCE_MS);
    });

    // Listen to htmx completion events to update status
    document.addEventListener('htmx:afterRequest', function (evt) {
      try {
        const xhr = evt.detail.xhr;
        if (xhr && xhr.responseURL && xhr.responseURL.includes('/richtext/architecture')) {
          if (xhr.status >= 200 && xhr.status < 300) {
            const t = new Date();
            autosaveStatus.textContent = 'Auto Saved — ' + t.toLocaleTimeString();
          } else {
            autosaveStatus.textContent = 'Save failed (status ' + xhr.status + ')';
          }
        }
      } catch (e) {
        // ignore
      }
    });

    // On main form submit, copy HTML into hidden input (keeps your original behaviour)
    const architectureForm = document.getElementById('architectureForm');
    const submitBtn = document.getElementById('submitBtn');
    if (architectureForm && submitBtn) {
      architectureForm.addEventListener('submit', function (e) {
        document.getElementById('editedDocument').value = quill.root.innerHTML;
        submitBtn.disabled = true;
        submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
        submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Submitting...';
      });
    }

    // Enhanced PDF export with proper table rendering
    async function downloadAsPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({
        unit: 'pt',
        format: 'a4',
        compress: true
      });

      const margin = 40;
      const pageHeight = pdf.internal.pageSize.getHeight();
      const pageWidth = pdf.internal.pageSize.getWidth();
      const contentWidth = pageWidth - (2 * margin);
      let y = margin;

      // Add logo to top right corner
      const logo = document.getElementById('pdfLogo');
      if (logo && logo.src) {
        try {
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();

          img.onload = function() {
            const logoWidth = 30;
            const logoHeight = 50;
            const logoX = pageWidth - margin - logoWidth;
            const logoY = margin;

            pdf.addImage(img, 'PNG', logoX, logoY, logoWidth, logoHeight);
            addDocumentContent();
          };

          img.onerror = function() {
            console.warn('Logo could not be loaded, proceeding without logo');
            addDocumentContent();
          };

          img.src = logo.src;

        } catch (error) {
          console.warn('Error loading logo:', error);
          addDocumentContent();
        }
      } else {
        addDocumentContent();
      }

      function addDocumentContent() {
        // Add document header (moved down to accommodate logo)
        y += 40; // Extra space for logo

        const projectName = document.querySelector('p.text-gray-600').textContent;
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(16);
        pdf.setTextColor(30, 64, 175); // Blue color
        pdf.text("Architecture Document", margin, y);

        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        pdf.text(projectName, margin, y + 20);

        y += 50;

        // Get the HTML content from the editor
        const htmlContent = getEditorHtmlPreservingTables();

        // Create a temporary div to process the content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlContent;

        // Function to check if we need a page break
        function checkPageBreak(heightNeeded = 0) {
          if (y + heightNeeded > pageHeight - margin) {
            pdf.addPage();
            y = margin;
            // Add logo to new page
            const logo = document.getElementById('pdfLogo');
            if (logo && logo.src) {
              try {
                const img = new Image();
                img.onload = function() {
                  const logoWidth = 30;
                  const logoHeight = 50;
                  const logoX = pageWidth - margin - logoWidth;
                  pdf.addImage(img, 'PNG', logoX, margin, logoWidth, logoHeight);
                };
                img.src = logo.src;
              } catch (error) {
                console.warn('Could not add logo to new page');
              }
            }
            return true;
          }
          return false;
        }

        // Function to add text with proper formatting
        function addText(text, fontSize = 12, isBold = false, indent = 0, lineHeight = 1.4, color = [55, 65, 81]) {
          pdf.setFont("helvetica", isBold ? "bold" : "normal");
          pdf.setFontSize(fontSize);
          pdf.setTextColor(...color);

          const lines = pdf.splitTextToSize(text, contentWidth - indent);
          const lineSpacing = fontSize * lineHeight;

          // Check if we need a page break before adding this text
          checkPageBreak(lines.length * lineSpacing);

          lines.forEach((line, index) => {
            // Check if we need a page break for each line
            if (y + lineSpacing > pageHeight - margin) {
              pdf.addPage();
              y = margin;
            }

            pdf.text(line, margin + indent, y);
            y += lineSpacing;
          });

          // Add a small gap after the text block
          y += 5;
        }

        // Process tables using jsPDF autotable for proper rendering
        function processTable(table) {
          const data = [];
          const headers = [];

          // Extract headers from thead if exists
          const thead = table.querySelector('thead');
          if (thead) {
            const headerRow = thead.querySelector('tr');
            if (headerRow) {
              Array.from(headerRow.querySelectorAll('th')).forEach(th => {
                headers.push(th.innerText.trim());
              });
              data.push(headers);
            }
          }

          // Extract data from tbody
          const tbody = table.querySelector('tbody') || table;
          const rows = tbody.querySelectorAll('tr');

          Array.from(rows).forEach(row => {
            // Skip header row if we already processed thead
            if (row.parentElement.tagName === 'THEAD') return;

            const rowData = [];
            Array.from(row.querySelectorAll('td, th')).forEach(cell => {
              rowData.push(cell.innerText.trim());
            });
            if (rowData.length > 0) {
              data.push(rowData);
            }
          });

          if (data.length > 0) {
            // Calculate table height
            const estimatedTableHeight = (data.length * 20) + 30;
            checkPageBreak(estimatedTableHeight);

            const tableConfig = {
              startY: y,
              margin: { left: margin, right: margin },
              styles: {
                fontSize: 10,
                cellPadding: 4,
                lineColor: [200, 200, 200],
                lineWidth: 0.5,
              },
              headStyles: {
                fillColor: [243, 244, 246],
                textColor: [55, 65, 81],
                fontStyle: 'bold',
              },
              alternateRowStyles: {
                fillColor: [250, 250, 250],
              },
              tableWidth: 'auto',
              columnStyles: {},
            };

            // If we have headers from thead, use them as proper headers
            if (thead && headers.length > 0) {
              const bodyData = data.slice(1); // Remove header row from data
              pdf.autoTable({
                head: [headers],
                body: bodyData,
                ...tableConfig
              });
            } else {
              // No explicit headers, treat first row as header
              pdf.autoTable({
                head: [data[0]],
                body: data.slice(1),
                ...tableConfig
              });
            }

            // Update y position after table
            const finalY = pdf.lastAutoTable.finalY || y + estimatedTableHeight;
            y = finalY + 20;
          }
        }

        // Process each node in the content
        function processNode(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent.trim()) {
              // Check if parent is bold
              const parent = node.parentElement;
              const isBold = parent && (
                      parent.tagName === 'STRONG' ||
                      parent.tagName === 'B' ||
                      parent.style.fontWeight === 'bold'
              );
              addText(node.textContent.trim(), 12, isBold);
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            const textContent = node.textContent.trim();

            if (!textContent && tag !== 'table' && tag !== 'div') return;

            switch(tag) {
              case "h1":
                addText(textContent, 18, true, 0, 1.4, [30, 64, 175]);
                y += 10;
                break;

              case "h2":
                addText(textContent, 16, true, 0, 1.4, [120, 10, 255]);
                y += 8;
                break;

              case "h3":
                addText(textContent, 14, true, 0, 1.4, [75, 123, 236]);
                y += 8;
                break;

              case "h4":
                addText(textContent, 13, true, 0, 1.4, [75, 85, 99]);
                y += 6;
                break;

              case "p":
                addText(textContent, 12, false);
                break;

              case "li":
                const isOrdered = node.parentElement && node.parentElement.tagName === 'OL';
                const prefix = isOrdered ?
                        (Array.from(node.parentElement.children).indexOf(node) + 1) + '. ' : '• ';
                addText(prefix + textContent, 12, false, 20);
                break;

              case "ul":
              case "ol":
                y += 8;
                Array.from(node.children).forEach(child => processNode(child));
                y += 8;
                break;

              case "strong":
              case "b":
                Array.from(node.childNodes).forEach(child => {
                  if (child.nodeType === Node.TEXT_NODE) {
                    addText(child.textContent.trim(), 12, true);
                  } else {
                    processNode(child);
                  }
                });
                break;

              case "table":
                processTable(node);
                break;

              case "div":
                if (node.classList.contains('component-box')) {
                  processComponentBox(node);
                } else if (node.classList.contains('architecture-diagram')) {
                  processArchitectureDiagram(node);
                } else if (node.classList.contains('ql-table-embed')) {
                  // Handle table embed div by processing the table inside
                  const table = node.querySelector('table');
                  if (table) processTable(table);
                } else {
                  Array.from(node.childNodes).forEach(processNode);
                }
                break;

              default:
                Array.from(node.childNodes).forEach(processNode);
            }
          }
        }

        // Process component boxes
        function processComponentBox(box) {
          checkPageBreak(40);

          pdf.setFont("helvetica", "bold");
          pdf.setFontSize(11);
          pdf.setTextColor(55, 65, 81);

          const text = pdf.splitTextToSize(box.textContent, contentWidth - 20);
          pdf.text(text, margin + 10, y + 18);

          y += 40;
        }

        // Process architecture diagrams
        function processArchitectureDiagram(diagram) {
          checkPageBreak(100);

          pdf.setFont("helvetica", "bold");
          pdf.setFontSize(12);
          pdf.setTextColor(100, 100, 100);
          pdf.text("Architecture Diagram", pageWidth / 2, y + 45, { align: 'center' });

          y += 100;
        }

        // Process all content nodes
        Array.from(tempDiv.childNodes).forEach(processNode);

        // Save the PDF
        pdf.save("architecture-document.pdf");
      }
    }

    /*********************************
     * Keep cell handlers attached after changes
     *********************************/
    quill.on('text-change', () => {
      // reattach behaviors (handles pasted tables or structural changes)
      setTimeout(() => {
        attachCellBehaviorToAllTables();
        processEnhancedContent();
      }, 0);
    });

    // If the editor loses focus and no table cell is focused, hide toolbar
    quill.root.addEventListener('focusout', (ev) => {
      // small timeout to allow focus to transfer to toolbar or other cell
      setTimeout(() => {
        if (!document.activeElement || !document.activeElement.closest || !document.activeElement.closest('.ql-table-embed')) {
          hideFloatingToolbar();
        }
      }, 120);
    });

    // Prevent accidental Quill edits inside the embed container itself
    quill.root.addEventListener('click', (e) => {
      const embed = e.target.closest('.ql-table-embed');
      if (embed && !e.target.closest('td,th')) {
        // click landed in embed container but not a cell — focus the first cell
        const firstCell = embed.querySelector('td,th');
        if (firstCell) {
          firstCell.focus();
          placeCaretAtEnd(firstCell);
        }
      }
    });

    // Make sure floating toolbar stays positioned if editor scrolls
    quill.root.addEventListener('scroll', () => {
      if (currentCell) showFloatingToolbarNearCell(currentCell);
    });
  </script>
</div>
</body>
</html>