<!DOCTYPE html>
<html lang="en"
      xmlns:th="http://www.thymeleaf.org"
      xmlns:layout="http://www.ultraq.net.nz/thymeleaf/layout"
      layout:decorate="~{layout}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Review SRS</title>

  <!-- Provide CSRF tokens when Spring Security is active -->
  <meta th:if="${_csrf != null}" name="_csrf" th:content="${_csrf.token}"/>
  <meta th:if="${_csrf != null}" name="_csrf_header" th:content="${_csrf.headerName}"/>

  <script src="https://cdn.tailwindcss.com"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
  <!-- Quill CSS -->
  <link href="https://cdn.quilljs.com/1.3.6/quill.snow.css" rel="stylesheet">

  <style>
    /* Editor container */
    .editor-wrapper {
      background: white;
      border-radius: 8px;
      padding: 1rem;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
    }

    #editor {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      height: 72vh;
      overflow-y: auto;
    }

    /* Quill editor content */
    .ql-editor {
      min-height: 300px;
      max-height: 100%;
      overflow-y: auto;
    }

    .ql-editor h1 {
      font-size: 1.875rem;
      font-weight: bold;
      color: #1e40af;
      margin-bottom: 1.5rem;
      padding-bottom: 0.5rem;
      border-bottom: 2px solid #e2e8f0;
    }

    .ql-editor h2 {
      font-size: 1.5rem;
      font-weight: bold;
      color: #780aff;
      margin-top: 1.5rem;
      margin-bottom: 1rem;
      padding-bottom: 0.25rem;
      border-bottom: 1px solid #e2e8f0;
    }

    .ql-editor h3 {
      font-size: 1.25rem;
      font-weight: 600;
      color: #4b7bec;
      margin-top: 1.25rem;
      margin-bottom: 0.75rem;
    }

    .ql-editor h4 {
      font-size: 1.1rem;
      font-weight: 600;
      color: #4b5563;
      margin-top: 1rem;
      margin-bottom: 0.5rem;
    }

    .ql-editor p {
      margin-bottom: 1rem;
      line-height: 1.6;
      color: #374151;
    }

    .ql-editor ul {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      list-style-type: disc;
    }

    .ql-editor ol {
      margin-bottom: 1rem;
      padding-left: 1.5rem;
      list-style-type: decimal;
    }

    .ql-editor li {
      margin-bottom: 0.5rem;
      line-height: 1.5;
    }

    .ql-editor strong {
      font-weight: 600;
      color: #4b5563;
    }

    /* Table styling inside Quill editor */
    .ql-editor table {
      width: 100%;
      border-collapse: collapse;
      margin-bottom: 1rem;
    }

    .ql-editor td,
    .ql-editor th {
      border: 1px solid #e5e7eb;
      padding: 0.5rem 0.75rem;
      vertical-align: top;
    }

    .ql-editor th {
      background-color: #f3f4f6;
      font-weight: 600;
      text-align: left;
    }

    /* Component box for architecture diagrams */
    .component-box {
      display: inline-block;
      background-color: #f3f4f6;
      border: 1px solid #e5e7eb;
      border-radius: 6px;
      padding: 8px 16px;
      margin: 4px;
      font-weight: 500;
    }

    /* Architecture diagram styling */
    .architecture-diagram {
      background-color: #f9fafb;
      border: 1px solid #e5e7eb;
      border-radius: 8px;
      padding: 1.5rem;
      margin: 1rem 0;
      text-align: center;
    }

    .gradient-bg {
      background: linear-gradient(135deg, #780aff 0%, #4b7bec 100%);
    }

    /* small UI niceties */
    .insert-table-btn i.fa-table { font-size: 14px; }
  </style>
</head>
<body>
<div layout:fragment="content">
  <!-- Page Title -->
  <div class="mb-8 mt-6">
    <h1 class="text-2xl md:text-3xl font-bold text-blue-800">
      <i class="fas fa-file-alt mr-3 text-blue-600"></i>
      Review SRS Document
    </h1>
    <p th:text="${processVariables.projectName}" class="text-gray-600 mt-2">E-Commerce Platform Project - v2.3</p>
  </div>

  <!-- Thymeleaf Form (kept so Complete Review still works server-side) -->
  <form id="srsForm" th:action="@{/tasks/complete/{taskId}(taskId=${taskId})}" method="post">
    <div class="bg-blue-50 border border-blue-100 rounded-lg p-4 mb-6 flex flex-wrap justify-between items-center">
      <div class="flex items-center">
        <span class="text-blue-800 mr-4 font-medium">Document Status:</span>
        <span class="bg-yellow-100 text-yellow-800 px-3 py-1 rounded-full text-sm">Under Review</span>
        <!-- autosave status -->
        <span id="autosaveStatus" class="ml-4 text-sm text-gray-600">Not saved</span>
      </div>

      <div class="flex space-x-3 mt-3 md:mt-0">
        <button onclick="downloadAsPDF()" type="button" id="downloadBtn"
                class="gradient-bg text-white px-4 py-2 rounded-lg flex items-center action-btn">
          <i class="fas fa-download mr-2"></i> Download
        </button>
      </div>
    </div>

    <!-- Hidden input used for the final form submit -->
    <input type="hidden" name="requirement" id="editedDocument"/>

    <!-- Quill Toolbar (custom HTML toolbar - custom table button is plain button, NOT ql- prefixed) -->
    <div class="editor-wrapper mb-4">
      <div id="toolbar" class="ql-toolbar ql-snow">
        <span class="ql-formats">
          <select class="ql-header" title="Heading">
            <option value="1">H1</option>
            <option value="2">H2</option>
            <option value="3">H3</option>
            <option selected>Normal</option>
          </select>
        </span>
        <span class="ql-formats">
          <button class="ql-bold" title="Bold"></button>
          <button class="ql-italic" title="Italic"></button>
          <button class="ql-underline" title="Underline"></button>
          <button class="ql-strike" title="Strike"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-list" value="ordered" title="Ordered list"></button>
          <button class="ql-list" value="bullet" title="Bullet list"></button>
        </span>
        <span class="ql-formats">
          <button class="ql-link" title="Link"></button>
          <button class="ql-image" title="Image"></button>
          <button class="ql-code-block" title="Code block"></button>
        </span>
        <span class="ql-formats">
          <select class="ql-color" title="Text color"></select>
          <select class="ql-background" title="Background color"></select>
        </span>
        <span class="ql-formats">
          <button class="ql-clean" title="Remove formatting"></button>
          <!-- NOTICE: This is a plain button (no 'ql-' prefix). Quill won't try to attach a format that doesn't exist. -->
          <button type="button" id="insertTableBtn" class="insert-table-btn" title="Insert table" aria-label="Insert table">
            <i class="fa fa-table"></i>
          </button>
        </span>
      </div>

      <!-- Quill Editor (editable) -->
      <div id="editor" th:utext="${processVariables.aiRequirementAnalysis}"></div>
    </div>

    <!-- Complete Button -->
    <div th:if="${!isCompleted}" class="flex justify-center mt-6">
      <button type="submit" id="submitBtn"
              class="gradient-bg text-white px-6 py-3 rounded-lg flex items-center action-btn">
        <i class="fas fa-check-circle mr-2"></i>
        Complete Review
      </button>
    </div>
  </form>

  <!-- Hidden logo for PDF generation -->
  <img id="pdfLogo" src="/images/JJ LOGOMARK COLORED.png" alt="Company Logo" style="display: none;">

  <!-- Scripts: htmx (for AJAX), Quill, jsPDF (kept) -->
  <script src="https://unpkg.com/htmx.org@1.9.2"></script>
  <script src="https://cdn.quilljs.com/1.3.6/quill.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.25/jspdf.plugin.autotable.min.js"></script>

  <script>
    // Initialize Quill using the toolbar container (our custom toolbar)
    var quill = new Quill('#editor', {
      theme: 'snow',
      modules: {
        toolbar: '#toolbar'
      }
    });

    // Custom table insertion using a plain button (prevents Quill from complaining
    // about a nonexistent 'table' format). This inserts a simple table HTML block.
    (function registerInsertTableButton() {
      const btn = document.getElementById('insertTableBtn');
      if (!btn) return;

      btn.addEventListener('click', function () {
        // Prompt user for table dimensions (simple and quick)
        let rows = parseInt(prompt('Enter number of rows (minimum 1):', '3'), 10);
        if (!rows || rows < 1) return;
        let cols = parseInt(prompt('Enter number of columns (minimum 1):', '3'), 10);
        if (!cols || cols < 1) return;

        const includeHeader = confirm('Include a header row? (OK = Yes, Cancel = No)');

        // Build table HTML
        const pieces = [];
        pieces.push('<table class="quill-table" style="width:100%;border-collapse:collapse;">');
        if (includeHeader) {
          pieces.push('<thead><tr>');
          for (let c = 0; c < cols; c++) {
            pieces.push('<th style="border:1px solid #e5e7eb;padding:8px;text-align:left;"></th>');
          }
          pieces.push('</tr></thead>');
        }
        pieces.push('<tbody>');
        for (let r = 0; r < rows; r++) {
          pieces.push('<tr>');
          for (let c = 0; c < cols; c++) {
            pieces.push('<td style="border:1px solid #e5e7eb;padding:8px;"></td>');
          }
          pieces.push('</tr>');
        }
        pieces.push('</tbody></table>');
        pieces.push('<p><br></p>'); // ensure a paragraph after the table so the cursor can move out

        const tableHtml = pieces.join('');

        // Insert at current selection or at the end
        const range = quill.getSelection(true);
        const index = (range && typeof range.index === 'number') ? range.index : quill.getLength();
        quill.clipboard.dangerouslyPasteHTML(index, tableHtml);

        // Move cursor to first cell by placing it just after the inserted table (basic)
        // Note: precise placement inside the cell is non-trivial without a table module.
        quill.setSelection(index + 1, 0);
        // Trigger an autosave immediately after insertion
        if (typeof autosaveContent === 'function') {
          autosaveContent();
        }
      });
    })();

    // --- CSRF integration for htmx (works if Spring Security provides _csrf) ---
    (function setupHtmxCsrf() {
      const metaToken = document.querySelector('meta[name="_csrf"]');
      const metaHeader = document.querySelector('meta[name="_csrf_header"]');
      if (metaToken && metaHeader && window.htmx) {
        const csrfToken = metaToken.getAttribute('content');
        const csrfHeader = metaHeader.getAttribute('content');
        // Add the CSRF header to every htmx request:
        document.addEventListener('htmx:configRequest', function (evt) {
          evt.detail.headers[csrfHeader] = csrfToken;
        });
      }
    })();

    // Debounced autosave using htmx.ajax on Quill changes
    const autosaveStatus = document.getElementById('autosaveStatus');
    let saveTimeout = null;
    const AUTOSAVE_DEBOUNCE_MS = 800; // reduce spamming by debouncing

    function autosaveContent() {
      const html = quill.root.innerHTML || '';
      autosaveStatus.textContent = 'Saving...';

      // use htmx.ajax to POST form-encoded data { requirement: html } to your endpoint
      // endpoint: POST /api/richtext
      htmx.ajax('POST', /* url */ '/richtext', {
        values: {
          requirement: html,
          taskId: '[[${taskId}]]'
        },
        swap: 'none' // we don't want to swap any content back into the page
      });
    }

    // debounce wrapper
    quill.on('text-change', function () {
      if (saveTimeout) clearTimeout(saveTimeout);
      saveTimeout = setTimeout(autosaveContent, AUTOSAVE_DEBOUNCE_MS);
    });

    // Listen to htmx completion events to update status
    document.addEventListener('htmx:afterRequest', function (evt) {
      try {
        const xhr = evt.detail.xhr;
        if (xhr && xhr.responseURL && xhr.responseURL.includes('/richtext')) {
          if (xhr.status >= 200 && xhr.status < 300) {
            const t = new Date();
            autosaveStatus.textContent = 'Auto Saved — ' + t.toLocaleTimeString();
          } else {
            autosaveStatus.textContent = 'Save failed (status ' + xhr.status + ')';
          }
        }
      } catch (e) {
        // ignore
      }
    });

    // On main form submit, copy HTML into hidden input (keeps your original behaviour)
    const srsForm = document.getElementById('srsForm');
    const submitBtn = document.getElementById('submitBtn');
    srsForm.addEventListener('submit', function (e) {
      document.getElementById('editedDocument').value = quill.root.innerHTML;
      submitBtn.disabled = true;
      submitBtn.classList.add('opacity-50', 'cursor-not-allowed');
      submitBtn.innerHTML = '<i class="fas fa-spinner fa-spin mr-2"></i> Submitting...';
    });

    // Enhanced PDF export with logo and removed borders
    async function downloadAsPDF() {
      const { jsPDF } = window.jspdf;
      const pdf = new jsPDF({
        unit: 'pt',
        format: 'a4',
        compress: true
      });

      const margin = 40;
      const pageHeight = pdf.internal.pageSize.getHeight();
      const pageWidth = pdf.internal.pageSize.getWidth();
      const contentWidth = pageWidth - (2 * margin);
      let y = margin;

      // Add logo to top right corner
      const logo = document.getElementById('pdfLogo');
      if (logo && logo.src) {
        try {
          // Create a canvas to handle the logo
          const canvas = document.createElement('canvas');
          const ctx = canvas.getContext('2d');
          const img = new Image();

          img.onload = function() {
            // Set logo dimensions
            const logoWidth = 30;
            const logoHeight = 50;
            const logoX = pageWidth - margin - logoWidth;
            const logoY = margin;

            // Add logo to PDF
            pdf.addImage(img, 'PNG', logoX, logoY, logoWidth, logoHeight);

            // Continue with document content after logo is loaded
            addDocumentContent();
          };

          img.onerror = function() {
            console.warn('Logo could not be loaded, proceeding without logo');
            addDocumentContent();
          };

          img.src = logo.src;

        } catch (error) {
          console.warn('Error loading logo:', error);
          addDocumentContent();
        }
      } else {
        addDocumentContent();
      }

      function addDocumentContent() {
        // Add document header (moved down to accommodate logo)
        y += 40; // Extra space for logo

        const projectName = document.querySelector('p.text-gray-600').textContent;
        pdf.setFont("helvetica", "bold");
        pdf.setFontSize(16);
        pdf.setTextColor(30, 64, 175); // Blue color
        pdf.text("SRS Document", margin, y);

        pdf.setFont("helvetica", "normal");
        pdf.setFontSize(12);
        pdf.setTextColor(100, 100, 100);
        pdf.text(projectName, margin, y + 20);

        y += 50;

        // Get the HTML content from the editor
        const htmlContent = quill.root.innerHTML;

        // Create a temporary div to process the content
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = htmlContent;

        // Function to check if we need a page break
        function checkPageBreak(heightNeeded = 0) {
          if (y + heightNeeded > pageHeight - margin) {
            pdf.addPage();
            y = margin;
            // Add logo to new page
            const logo = document.getElementById('pdfLogo');
            if (logo && logo.src) {
              try {
                const img = new Image();
                img.onload = function() {
                  const logoWidth = 30;
                  const logoHeight = 50;
                  const logoX = pageWidth - margin - logoWidth;
                  pdf.addImage(img, 'PNG', logoX, margin, logoWidth, logoHeight);
                };
                img.src = logo.src;
              } catch (error) {
                console.warn('Could not add logo to new page');
              }
            }
            return true;
          }
          return false;
        }

        // Function to add text with proper formatting (borders removed)
        function addText(text, fontSize = 12, isBold = false, indent = 0, lineHeight = 1.4, color = [55, 65, 81]) {
          pdf.setFont("helvetica", isBold ? "bold" : "normal");
          pdf.setFontSize(fontSize);
          pdf.setTextColor(...color);

          const lines = pdf.splitTextToSize(text, contentWidth - indent);
          const lineSpacing = fontSize * lineHeight;

          // Check if we need a page break before adding this text
          checkPageBreak(lines.length * lineSpacing);

          lines.forEach((line, index) => {
            // Check if we need a page break for each line
            if (y + lineSpacing > pageHeight - margin) {
              pdf.addPage();
              y = margin;
            }

            pdf.text(line, margin + indent, y);
            y += lineSpacing;
          });

          // Add a small gap after the text block
          y += 5;
        }

        // Process each node in the content
        function processNode(node) {
          if (node.nodeType === Node.TEXT_NODE) {
            if (node.textContent.trim()) {
              // Check if parent is bold
              const parent = node.parentElement;
              const isBold = parent && (
                      parent.tagName === 'STRONG' ||
                      parent.tagName === 'B' ||
                      parent.style.fontWeight === 'bold'
              );
              addText(node.textContent.trim(), 12, isBold);
            }
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName.toLowerCase();
            const textContent = node.textContent.trim();

            if (!textContent && tag !== 'table') return;

            switch(tag) {
              case "h1":
                addText(textContent, 18, true, 0, 1.4, [30, 64, 175]);
                // Removed border line under h1
                y += 10;
                break;

              case "h2":
                addText(textContent, 16, true, 0, 1.4, [120, 10, 255]);
                // Removed border line under h2
                y += 8;
                break;

              case "h3":
                addText(textContent, 14, true, 0, 1.4, [75, 123, 236]);
                y += 8;
                break;

              case "h4":
                addText(textContent, 13, true, 0, 1.4, [75, 85, 99]);
                y += 6;
                break;

              case "p":
                addText(textContent, 12, false);
                break;

              case "li":
                const isOrdered = node.parentElement && node.parentElement.tagName === 'OL';
                const prefix = isOrdered ?
                        (Array.from(node.parentElement.children).indexOf(node) + 1) + '. ' : '• ';
                addText(prefix + textContent, 12, false, 20);
                break;

              case "ul":
              case "ol":
                y += 8;
                Array.from(node.children).forEach(child => processNode(child));
                y += 8;
                break;

              case "strong":
              case "b":
                Array.from(node.childNodes).forEach(child => {
                  if (child.nodeType === Node.TEXT_NODE) {
                    addText(child.textContent.trim(), 12, true);
                  } else {
                    processNode(child);
                  }
                });
                break;

              case "table":
                processTable(node);
                break;

              case "div":
                if (node.classList.contains('component-box')) {
                  processComponentBox(node);
                } else if (node.classList.contains('architecture-diagram')) {
                  processArchitectureDiagram(node);
                } else {
                  Array.from(node.childNodes).forEach(processNode);
                }
                break;

              default:
                Array.from(node.childNodes).forEach(processNode);
            }
          }
        }

        // Process tables (with simplified styling - borders removed)
        function processTable(table) {
          const rows = [];
          table.querySelectorAll("tr").forEach(tr => {
            const row = [];
            tr.querySelectorAll("td, th").forEach(cell => {
              row.push({
                content: cell.innerText.trim(),
                isHeader: cell.tagName === 'TH'
              });
            });
            rows.push(row);
          });

          if (rows.length > 0) {
            checkPageBreak(100); // Reserve space for table

            const columnWidths = Array(rows[0].length).fill(contentWidth / rows[0].length);
            const startY = y;

            // Draw table header (simplified - no background color)
            const headerRow = rows[0];
            const rowHeight = 25;

            // Draw header text (no background)
            pdf.setFont("helvetica", "bold");
            pdf.setFontSize(10);
            pdf.setTextColor(55, 65, 81); // Regular text color instead of white

            headerRow.forEach((cell, index) => {
              const x = margin + (index * columnWidths[index]);
              const cellContent = pdf.splitTextToSize(cell.content, columnWidths[index] - 10);
              pdf.text(cellContent, x + 5, y + 15);
            });

            y += rowHeight;

            // Draw table rows (simplified - no alternating colors)
            pdf.setFont("helvetica", "normal");
            pdf.setFontSize(10);
            pdf.setTextColor(55, 65, 81);

            for (let i = 1; i < rows.length; i++) {
              checkPageBreak(rowHeight);

              const row = rows[i];
              row.forEach((cell, index) => {
                const x = margin + (index * columnWidths[index]);
                const cellContent = pdf.splitTextToSize(cell.content, columnWidths[index] - 10);
                pdf.text(cellContent, x + 5, y + 15);
              });

              y += rowHeight;
            }

            // Removed table borders
            y += 20;
          }
        }

        // Process component boxes (borders removed)
        function processComponentBox(box) {
          checkPageBreak(40);

          // Removed background and border
          pdf.setFont("helvetica", "bold");
          pdf.setFontSize(11);
          pdf.setTextColor(55, 65, 81);

          const text = pdf.splitTextToSize(box.textContent, contentWidth - 20);
          pdf.text(text, margin + 10, y + 18);

          y += 40;
        }

        // Process architecture diagrams (borders removed)
        function processArchitectureDiagram(diagram) {
          checkPageBreak(100);

          // Removed background and border
          pdf.setFont("helvetica", "bold");
          pdf.setFontSize(12);
          pdf.setTextColor(100, 100, 100);
          pdf.text("Architecture Diagram", pageWidth / 2, y + 45, { align: 'center' });

          y += 100;
        }

        // Process all content nodes
        Array.from(tempDiv.childNodes).forEach(processNode);

        // Save the PDF
        pdf.save("srs-document.pdf");
      }
    }
  </script>
</div>
</body>
</html>
